# Monte Carlo Management (McM)

Welcome to McM, the main tool for the CMS experiment for requesting and bookkeeping the production of central Monte Carlo (MC) samples. If you would like to see a detailed overview of the features of this tool, we invite you to check:

- [An overview of McM - 17th CMS Induction Course](https://indico.cern.ch/event/1467816/contributions/6349484/attachments/3009405/5305686/CMS_Samadhan_Induction_PdmV_0502025.pdf)
- [Monte Carlo production tools](https://cms-pdmv.gitbook.io/project)

## How does this tool work?

This tool is composed of three main components: A web application for bookkeeping and orchestrate requests, an embedded module ([wmcontrol](https://github.com/cms-PdmV/wmcontrol)) for submitting the request's configuration and workflow task dictionary to [ReqMgr2](https://cms-wmcore.docs.cern.ch/wmcore/Request-Manager-%28ReqMgr2%29-REST-APIs/) and a database layer (with its search engine) for storing the requests.

As a really brief and quick introduction, each `request` in the application represents a step in the MC simulation and its configuration will be generated by an execution of `cmsDriver.py`, provided into [cms-sw](https://github.com/cms-sw/cmssw) releases, specifying on it several configuration parameters. For example, for a generation step:

```bash
# Request B2G-Run3Summer19wmLHEGS-00001
# CMSSW release: CMSSW_10_6_1
cmsDriver.py Configuration/GenProduction/python/B2G-Run3Summer19wmLHEGS-00001-fragment.py --python_filename B2G-Run3Summer19wmLHEGS-00001_1_cfg.py --eventcontent RAWSIM,LHE --customise Configuration/DataProcessing/Utils.addMonitoring --datatier GEN-SIM,LHE --fileout file:B2G-Run3Summer19wmLHEGS-00001.root --conditions 106X_upgrade2021_realistic_v4 --beamspot Run3RoundOptics25ns13TeVHighSigmaZ --step LHE,GEN,SIM --geometry DB:Extended --era Run3 --no_exec --mc -n 1000;
```

Requests are grouped into chained requests (`chained_requests`) that represent the production of a complete MC sample and several output [formats](https://cms-opendata-guide.web.cern.ch/cmssw/cmsswdatamodel/) for the generation (primary) dataset. The configuration for each request (step) in the chained request is uploaded individually to **ReqMgr2** and the configuration for the complete MC sample is translated to a `task` configuration which specifies the MC steps, its output dataset name, and other metadata that describes how the MC sample will be computed by **ReqMgr2**, the central workflow management system for the CMS experiment. After the `task` configuration is prepared and submitted to **ReqMgr2**, using the embedded modules provided by `wmcontrol`, the MC sample is set to be computed, and the result output datasets will be available via **DBS**, which can be queried via [DAS](https://cmsweb.cern.ch/das/faq).

## How to deploy a development version?

> [!IMPORTANT]  
> There are several prerequisites you must fulfill before deploying a development version of this tool:

- Have a CERN account with access to the [lxplus](https://lxplusdoc.web.cern.ch/) service or to a VM node located inside the CERN general purpose network.
- Have an X.509 certificate to authenticate to the CMS Web Services (in specific to ReqMgr2). Please follow these guidelines to request one if required [Personal certificates from CERN](https://twiki.cern.ch/twiki/bin/view/CMSPublic/PersonalCertificate) - [Basic requirements for using the Grid](https://twiki.cern.ch/twiki/bin/view/CMSPublic/WorkBookStartingGrid#BasicGrid).
- Have `docker` and `docker compose` available in your development environment. If you do not have it already, you could install by following the guidelines at: [Install Docker Engine](https://docs.docker.com/engine/install/).
- Have `python3.11` installed for your development environment. If you do not have it already, you could install it via [pyenv](https://github.com/pyenv/pyenv).
- Have `node` installed for your development environment. It is recommended to use the latest LTS version, nevertheless any version `node > 16` should work. If you do not have it already, you could install it via [nvm](https://github.com/nvm-sh/nvm).
- Have downloaded the following CouchDB database dump for setting up the application's database: [Sample backup](https://cernbox.cern.ch/files/spaces/eos/user/p/pdmvserv/McM/samples/mcm-test-data.tar.gz)
- Have a copy of this repository, fork it.

After you fulfill these prerequisites, follow the next steps:

1. Clone the forked repository you created before
2. Access the forked repository folder and the `mcm` folder.
3. Access the `deploy` folder, create a copy of the `.env.template` named `.env` and leave inside the `deploy` folder.
4. Edit the `.env` file and set up the required variables highlighted by a `TODO`, then save the changes.
5. Load the configuration via: `set -a; source .env; set +a`
6. Set the McM source you would like to deploy via the `MCM_DOCKERFILE_PATH` variable, e.g: `export MCM_DOCKERFILE_PATH='https://github.com/cms-PdmV/cmsPdmV.git#migration/current-python3:mcm'`. Read this [article](https://docs.docker.com/reference/compose-file/build/#attributes) for more details.
7. Deploy the application components via: `cd "${REPO_PATH}" && ./deploy/action.sh --up`

After completing this steps, you will have three containers running: The `web application`, the `CouchDB database` and its search engine `CouchDB Lucene`. Look for their URLs in the localhost scope by executing: `docker ps -a`.

### Deploy the web application without using containers
If you would like to deploy the web application without using containers, after you have completed the steps above:

- Overwrite the following environment variables:
```bash
# Set another free port, e.g: 8001
export MCM_PORT='8001'
export MCM_COUCHDB_URL="http://localhost:${COUCHDB_PORT}/"
export MCM_LUCENE_URL="http://localhost:${LUCENE_PORT}/"
```
- Create a virtual environment, activate the environment and install the required dependencies: `python3.11 -m venv venv && source ./venv/bin/activate && pip install -r requirements.txt`
- Install `node` dependencies and generate the web build via: `npm i && ./node_modules/grunt/bin/grunt`
- Start the web application: `python main.py > mcm.log 2>&1 & echo $! > "mcm.pid"`
- To exit, kill the process: `kill -9 $(cat mcm.pid)`

### Remove deployment

Remove the containers' deployment by executing: `deploy/action.sh --down`

> [!WARNING]
> You may want to remove the McM image too.
> 
> The last process just takes down the deployment, however, if you set it up again, the container you will use has the same image with the same changes of your last execution. Remove the image via: `docker rmi default-mcm-application` if you want to pull new changes before setting up the deployment again.

### Set up a reverse proxy

If you would like to see the web page in your browser and easily interact with the API, you need to configure a reverse proxy for serving the page properly and send any request impersonating a dummy user. To achieve this, follow the next steps:

- Modify the script `deploy/proxy.sh`, set your email address, and run the script.

This will install [caddy](https://github.com/caddyserver/caddy) and configure it for you with the required headers and redirection.

- Shutdown the proxy via: `kill -9 $(cat "./caddy/caddy.pid")`

In case you are deploying the application in an internal node and if you require it, you can forward the traffic to your personal machine via: 
```
ssh -f -N -L <local-port>:localhost:10000 <remote-user>@<remote-host>
```
Then, you should be able to see the web page in your browser by accessing: `http://localhost:<local-port>/mcm/`
